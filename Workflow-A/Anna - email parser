{
  "name": "Workflow A - Email parser",
  "nodes": [
    {
      "parameters": {
        "content": "## 1. Ingestion\nTriggers on manual execute or schedule. Fetches email with label 'travel' from Gmail, including attachments.",
        "height": 132,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1424,
        896
      ],
      "id": "b838a723-a135-4b55-8057-f0e502207d14",
      "name": "Sticky Note 1"
    },
    {
      "parameters": {
        "content": "## 2. Preprocessing\nCustom JS decodes base64url email bodies, strips HTML tags to produce clean text, identifies/flags PDF attachments for the OCR branch.",
        "height": 148,
        "width": 256,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1088,
        896
      ],
      "id": "2f9d9620-0f6e-44d4-977d-3ff40daf6504",
      "name": "Sticky Note 2"
    },
    {
      "parameters": {
        "content": "## 3. OCR Branch\nConditional logic routes PDFs here. The node extracts raw text content from each PDF attachment found.",
        "height": 132,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -720,
        896
      ],
      "id": "3d5c5e97-a8fb-48cf-8068-574f936fbd51",
      "name": "Sticky Note 3"
    },
    {
      "parameters": {
        "content": "## 4. Aggregation\nMerges the processed email body with the extracted text from its PDF attachments. Groups everything by Message ID to ensure a single context object per email.",
        "height": 164,
        "width": 256,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -272,
        896
      ],
      "id": "78a50ec7-2235-435a-9568-44add8d21382",
      "name": "Sticky Note 4"
    },
    {
      "parameters": {
        "content": "## 5. AI Extraction\nSends the consolidated text (Email + PDF) to GPT-4.1 mini. The model classifies the booking type and extracts structured data that you want to save in database (activity, dates, notes) matching the schema.",
        "height": 164,
        "width": 272,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        96,
        896
      ],
      "id": "c1b334ea-fa36-40fc-bde3-d4836bce079f",
      "name": "Sticky Note 5"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1616,
        1056
      ],
      "id": "f4e1c204-9f34-40ea-9510-21a733dcdeb8",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": true,
        "simple": false,
        "filters": {
          "labelIds": [
            "Label_4554956988318047131"
          ],
          "readStatus": "both"
        },
        "options": {
          "downloadAttachments": true
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1392,
        1152
      ],
      "id": "1d8a4b17-1b66-4f1b-acdf-7e2937d22563",
      "name": "Get many messages",
      "webhookId": "d50e2464-4c2d-4977-bc70-1611e6764f00",
      "credentials": {
        "gmailOAuth2": {
          "id": "b4SDfak7CuGCYNhP",
          "name": "Gmail account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items\nconst items = $input.all();\nconst out = [];\n\nfunction b64urlDecode(s = \"\") {\n  s = s.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const pad = s.length % 4 ? \"=\".repeat(4 - (s.length % 4)) : \"\";\n  return Buffer.from(s + pad, \"base64\").toString(\"utf8\");\n}\n\nfunction stripHtml(html = \"\") {\n  return html\n    .replace(/<style[\\s\\S]*?<\\/style>/gi, \"\")\n    .replace(/<script[\\s\\S]*?<\\/script>/gi, \"\")\n    .replace(/<\\/p>/gi, \"\\n\")\n    .replace(/<br\\s*\\/?>/gi, \"\\n\")\n    .replace(/<[^>]+>/g, \"\")\n    .replace(/&nbsp;/g, \" \")\n    .replace(/&amp;/g, \"&\")\n    .replace(/&lt;/g, \"<\")\n    .replace(/&gt;/g, \">\");\n}\n\nfunction findPart(payload, mime) {\n  const stack = [payload].filter(Boolean);\n  while (stack.length) {\n    const p = stack.pop();\n    if (p?.mimeType === mime && p?.body?.data) return p;\n    if (p?.parts?.length) stack.push(...p.parts);\n  }\n  return null;\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const emailJson = items[i].json ?? {};\n  const emailBin = items[i].binary ?? {};\n\n  const messageId =\n    emailJson.id ||\n    emailJson.messageId ||\n    emailJson.threadId ||\n    String(emailJson.internalDate || i);\n\n  const payload = emailJson.payload;\n\n  const plain = findPart(payload, \"text/plain\");\n  const html = findPart(payload, \"text/html\");\n\n  const emailText =\n    emailJson.textPlain ||\n    emailJson.text ||\n    (plain ? b64urlDecode(plain.body.data) : \"\") ||\n    (html ? stripHtml(b64urlDecode(html.body.data)) : \"\") ||\n    emailJson.snippet ||\n    \"\";\n\n  out.push({\n    json: {\n      type: \"email\",\n      messageId,\n      subject: emailJson.headers?.subject ?? \"\",\n      from: emailJson.headers?.from ?? \"\",\n      date: emailJson.date ?? emailJson.headers?.date ?? \"\",\n      emailText,\n      raw: emailJson,\n      hasPdfs: false,\n      pdfCount: 0,\n    },\n  });\n\n  const pdfEntries = Object.entries(emailBin).filter(([_, b]) => {\n    const mt = (b?.mimeType || \"\").toLowerCase();\n    const fn = (b?.fileName || \"\").toLowerCase();\n    return mt.includes(\"pdf\") || fn.endsWith(\".pdf\");\n  });\n\n  out[out.length - 1].json.hasPdfs = pdfEntries.length > 0;\n  out[out.length - 1].json.pdfCount = pdfEntries.length;\n\n  for (const [key, b] of pdfEntries) {\n    // IMPORTANT: keep customData so you can recover messageId/fileName later\n    b.customData = { ...(b.customData || {}), messageId, fileName: b.fileName || key };\n\n    out.push({\n      json: { type: \"pdf\", messageId, attachmentKey: key, fileName: b.fileName || key, mimeType: b.mimeType || \"application/pdf\" },\n      binary: { attachment: b },\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        1152
      ],
      "id": "0e530ce4-ead5-43ae-8837-b8d1192f4492",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "attachment",
        "options": {
          "keepSource": "json"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        -720,
        1232
      ],
      "id": "1dff118c-2eb8-4c11-851f-4632a17270eb",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "347b4335-de9c-4073-8314-d0709303038d",
              "leftValue": "={{ $json.type }}",
              "rightValue": "pdf",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -944,
        1152
      ],
      "id": "37b47ce1-04a5-4b21-a860-892363c65281",
      "name": "If"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -272,
        1152
      ],
      "id": "6404d5a7-4023-450f-89a2-e4148429f109",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({\n  json: {\n    type: \"pdfText\",\n    messageId: item.json.messageId,\n    fileName: item.json.fileName,\n    text: item.json.text || \"\",\n  },\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        1232
      ],
      "id": "1b829030-495c-46ce-994e-7c9becfec3ac",
      "name": "Code in JavaScript2"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst byId = new Map();\n\nfor (const item of items) {\n  const j = item.json || {};\n  const messageId = j.messageId;\n  if (!messageId) continue;\n\n  if (!byId.has(messageId)) {\n    byId.set(messageId, {\n      json: { messageId, subject: null, from: null, date: null, emailText: null, pdfs: [] },\n      pairedItem: item.pairedItem || { item: 0 }\n    });\n  }\n\n  const agg = byId.get(messageId);\n\n  // email rows\n  if (j.type === \"email\") {\n    agg.json.subject = j.subject;\n    agg.json.from = j.from;\n    agg.json.date = j.date;\n    agg.json.emailText = j.emailText;\n    continue;\n  }\n\n  // pdf rows AFTER Extract From File (they have j.text + numpages etc)\n  if (typeof j.text === \"string\" && j.text.trim()) {\n    agg.json.pdfs.push({\n      fileName: j.fileName || j.attachmentKey || \"attachment.pdf\",\n      text: j.text,\n    });\n  }\n}\n\n// Convert to array and ensure all items have pairedItem\nconst results = Array.from(byId.values());\nreturn results.map((item, index) => ({\n  json: item.json,\n  pairedItem: { item: index }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        1152
      ],
      "id": "2e073b56-88e0-4e79-bd32-934b59afcd58",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a travel itinerary extraction assistant.\n\nthe email address is this: annamaria.blasiak@gmail.com\n\nYour task is to extract clean, user-visible itinerary timeline segments from travel-related emails and attachments.\nEach segment represents ONE concrete item that can appear in a daily itinerary and must be ready to be saved directly into a database.\n\nYou must return ONLY valid JSON matching the provided schema.\nDo not include explanations or text outside the JSON.\nDo not invent data. If information is missing, return null.\n\n––––––––––––––––––––\nINPUT\n––––––––––––––––––––\n\nYou will receive:\n• subject\n• from\n• date\n• emailText (plain text or cleaned HTML)\n• optional pdfs[] where each item has:\n  - fileName\n  - text (OCR or extracted PDF text)\n\nThe content may include confirmations, itineraries, tickets, or receipts.\n\n––––––––––––––––––––\nGENERAL RULES\n––––––––––––––––––––\n\n• Prefer PDF text over emailText when both exist.\n• If multiple PDFs exist, use the one with the most complete itinerary.\n• Normalize airline, hotel, provider, city, and location names.\n• Convert dates/times to ISO-8601 when possible.\n• Include timezone ONLY if explicitly stated.\n• If only a date is known, return null for time fields.\n• Do NOT include marketing, legal, or footer text.\n• Notes should contain only traveler-useful information.\n• Assign a confidence score (0–1) for each segment.\n• If no itinerary items are present, return an empty segments array.\n\n––––––––––––––––––––\nSEGMENT SPLITTING RULES\n––––––––––––––––––––\n\n• One flight leg = one segment.\n• One hotel stay = one segment.\n• One tour / attraction / reservation = one segment.\n• One transport booking (train, bus, ferry, taxi, transfer) = one segment.\n• Do NOT merge unrelated items into a single segment.\n\n––––––––––––––––––––\nSEGMENT TYPES & EXTRACTION RULES\n––––––––––––––––––––\n\nFLIGHT (type: \"flight\")\n• Create one segment per flight leg.\n• title: \"Flight <FLIGHT_NUMBER>\" or \"Flight to <DESTINATION>\"\n• start_time: scheduled departure datetime\n• end_time: scheduled arrival datetime\n• start_location: departure airport\n• end_location: arrival airport\n• provider: airline name\n• confirmation: booking reference / record locator\n• notes: terminal, gate, baggage rules, boarding time\n\nACCOMMODATION (type: \"accommodation\")\n• One segment per hotel stay.\n• title: hotel name\n• start_time: check-in date (time optional)\n• end_time: check-out date (time optional)\n• start_location: hotel address or city\n• provider: hotel name or booking platform\n• confirmation: reservation number\n• description: room type or rate description\n• notes: check-in instructions, amenities\n\nACTIVITY / TOUR (type: \"activity\")\n• Create for tours, attractions, tickets, experiences.\n• title: activity or attraction name\n• start_time: activity start datetime\n• end_time: activity end datetime or null\n• start_location: venue or meeting point\n• provider: tour operator or venue\n• confirmation: booking or ticket reference\n• notes: entry instructions, dress code, meeting details\n\nTRANSPORT (non-flight) (type: \"transport\")\n• Use for trains, buses, ferries, transfers.\n• title: \"<MODE> to <DESTINATION>\"\n• start_time: departure datetime\n• end_time: arrival datetime\n• start_location: departure station/terminal\n• end_location: arrival station/terminal\n• provider: transport operator\n• confirmation: ticket or booking reference\n• notes: boarding info, luggage rules\n\nCAR RENTAL (type: \"car\")\n• title: \"Car rental – <PROVIDER>\"\n• start_time: pickup datetime\n• end_time: drop-off datetime\n• start_location: pickup location\n• end_location: drop-off location\n• provider: rental company\n• confirmation: reservation number\n• notes: fuel policy, insurance, pickup instructions\n\nMEAL / RESTAURANT (type: \"meal\")\n• title: restaurant name\n• start_time: reservation datetime\n• start_location: restaurant address or city\n• provider: restaurant or booking platform\n• confirmation: reservation reference\n• notes: dietary notes, dress code\n\nCRUISE (type: \"cruise\")\n• title: cruise or ship name\n• start_time: embarkation datetime\n• end_time: disembarkation datetime\n• start_location: departure port\n• end_location: arrival port\n• provider: cruise line\n• confirmation: booking reference\n• notes: cabin info, boarding instructions\n\nOTHER (type: \"other\")\n• Use only if travel-related but does not fit any category above.\n• Do NOT create segments for pure marketing emails.\n\n––––––––––––––––––––\nTRIP MATCHING\n––––––––––––––––––––\n\nAttempt to match this email to a trip based on:\n• destination names\n• date overlap\n• provider context\n\nIf a trip UUID is already known, include it.\nIf no confident match exists, set tripId to null and explain why.\n\n––––––––––––––––––––\nINPUT DATA\n––––––––––––––––––––\n\nsubject: {{$json.subject}}\nfrom: {{$json.from}}\ndate: {{$json.date}}\nemailText: {{$json.emailText}}\npdfs: {{$json.pdfs}}\n",
        "hasOutputParser": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        176,
        1152
      ],
      "id": "3881943f-cf51-43a0-9f3b-92c707dc2e7b",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        176,
        1376
      ],
      "id": "4c0d1b85-4ec9-43ac-9c39-102d3e542855",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "LlL0d4Bt4ZVRhpZi",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"user_email\": {\n      \"type\": \"string\",\n      \"description\": \"Email address associated with this extraction\",\n      \"default\": \"annamaria.blasiak@gmail.com\"\n    },\n    \"tripMatch\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"tripId\": { \"type\": [\"string\", \"null\"] },\n        \"matchConfidence\": { \"type\": \"number\" },\n        \"matchReason\": { \"type\": [\"string\", \"null\"] }\n      }\n    },\n    \"segments\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"type\": \"string\",\n            \"enum\": [\n              \"flight\",\n              \"transport\",\n              \"accommodation\",\n              \"activity\",\n              \"meal\",\n              \"car\",\n              \"cruise\",\n              \"other\"\n            ]\n          },\n          \"title\": { \"type\": \"string\" },\n          \"start_time\": { \"type\": [\"string\", \"null\"] },\n          \"end_time\": { \"type\": [\"string\", \"null\"] },\n          \"start_location\": { \"type\": [\"string\", \"null\"] },\n          \"end_location\": { \"type\": [\"string\", \"null\"] },\n          \"provider\": { \"type\": [\"string\", \"null\"] },\n          \"confirmation\": { \"type\": [\"string\", \"null\"] },\n          \"website\": { \"type\": [\"string\", \"null\"] },\n          \"phone\": { \"type\": [\"string\", \"null\"] },\n          \"description\": { \"type\": [\"string\", \"null\"] },\n          \"notes\": { \"type\": [\"string\", \"null\"] },\n          \"confidence\": { \"type\": \"number\" }\n        },\n        \"required\": [\"type\", \"title\"]\n      }\n    }\n  },\n  \"required\": [\"segments\"]\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        320,
        1376
      ],
      "id": "4a238eb1-9d0a-481f-b4cb-2f5f26997e1f",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "content": "##  WORKFLOW A - Email Parser Agent\n- matching email with the right user\n- relevant email content extraction\n- finding matching trips based on dates and location from the extracted email\n- creating/updating segments in the correct trip",
        "width": 448,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1536,
        640
      ],
      "id": "72d90d91-0cef-4545-91c7-7fddef58321e",
      "name": "Sticky Note "
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1616,
        1248
      ],
      "id": "81a4991e-08ac-4e98-a2e1-0cd3acf31edd",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "segments",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "trip_id",
              "condition": "eq",
              "keyValue": "={{$json.trip_id}}"
            },
            {
              "keyName": "source_message_id",
              "condition": "eq",
              "keyValue": "={{$json.source_message_id}}"
            },
            {
              "keyName": "type",
              "condition": "eq",
              "keyValue": "={{$json.type}}"
            },
            {
              "keyName": "title",
              "condition": "eq",
              "keyValue": "={{$json.title}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        480,
        1152
      ],
      "id": "d3591113-af57-4912-8a39-2dbd4f1ccdaf",
      "name": "Supabase - Get many rows",
      "credentials": {
        "supabaseApi": {
          "id": "2iEo9hyw5QPufkeh",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "content": "## 6. Database check\nCode in JS creates clean rows shaped exactly like Supabase expects. Linking segments to the trips.",
        "height": 164,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        416,
        896
      ],
      "id": "0cddf508-c5bc-4b89-9a2c-af3de6d31846",
      "name": "Sticky Note 6"
    },
    {
      "parameters": {
        "content": "## 7. Database change\nDatabase is updated or new row is created if new information is detected.",
        "height": 164
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        704,
        896
      ],
      "id": "5a8aa45f-41d1-486a-811d-7638541976db",
      "name": "Sticky Note 7"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node\n * Goal: output EXACTLY ONE validated segment (the “best” one) and shape it\n *       as a single Supabase row insert object.\n *\n * Assumptions:\n * - AI output is at $json.output\n * - $json.output.segments is an array (may be empty)\n * - Each segment has optional `confidence` (number)\n * - You want one row per email execution (best segment only)\n */\n\nconst items = $input.all();\nconst out = [];\n\nfunction pickBestSegment(segments) {\n  if (!Array.isArray(segments) || segments.length === 0) return null;\n\n  // Prefer highest confidence; fallback to first segment\n  const withConf = segments\n    .map((s, idx) => ({ s, idx, conf: typeof s?.confidence === 'number' ? s.confidence : -1 }))\n    .sort((a, b) => b.conf - a.conf);\n\n  const best = withConf[0]?.s ?? segments[0];\n\n  // Basic validation: must have type + title\n  if (!best?.type || !best?.title) return null;\n\n  return best;\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const json = items[i].json || {};\n  const aiOutput = json.output || {};\n  const tripMatch = aiOutput.tripMatch || {};\n  const segments = aiOutput.segments || [];\n\n  // Prefer explicit user_email if present, otherwise fallback to from\n  const userEmail = json.user_email || json.from || \"annamaria.blasiak@gmail.com\";\n\n  // Prefer messageId keys you might have from Gmail node\n  const sourceEmailId =\n    json.messageId ||\n    json.source_email_id ||\n    json.gmailMessageId ||\n    json.source?.gmailMessageId ||\n    null;\n\n  // Pick ONE segment\n  const segment = pickBestSegment(segments);\n\n  if (!segment) {\n    out.push({\n      json: {\n        skip: true,\n        reason: \"No validated segment (missing type/title or empty segments)\",\n        user_email: userEmail,\n        source_email_id: sourceEmailId\n      },\n      pairedItem: { item: i }\n    });\n    continue;\n  }\n\n  // Build ONE Supabase insert row (single item output)\n  out.push({\n    json: {\n      // ---- identifiers / context (optional) ----\n      user_email: userEmail,\n      source_email_id: sourceEmailId,\n\n      // Trip match (optional; you can later map to trip_id/user_id)\n      suggested_trip_id: tripMatch.tripId ?? null,\n      match_confidence: typeof tripMatch.matchConfidence === \"number\" ? tripMatch.matchConfidence : 0,\n      match_reason: tripMatch.matchReason ?? null,\n\n      // ---- segment fields ----\n      segment_type: segment.type ?? \"other\",\n      title: segment.title ?? \"Untitled\",\n      start_time: segment.start_time ?? null,\n      end_time: segment.end_time ?? null,\n      start_location: segment.start_location ?? null,\n      end_location: segment.end_location ?? null,\n      provider: segment.provider ?? null,\n      confirmation: segment.confirmation ?? null,\n      website: segment.website ?? null,\n      phone: segment.phone ?? null,\n      description: segment.description ?? null,\n      notes: segment.notes ?? null,\n\n      // optional segment confidence\n      confidence: typeof segment.confidence === \"number\" ? segment.confidence : null\n    },\n    pairedItem: { item: i }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        672
      ],
      "id": "9e6bee85-62e5-457b-86f6-08ed19b19594",
      "name": "Code in JavaScript3"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8b6d49bb-ddb2-4705-af96-142a74302c64",
              "leftValue": "={{$items(\"Supabase - Get many rows\").length}}\n",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        656,
        1152
      ],
      "id": "78290481-6db2-460c-9821-6f2914d6b5b2",
      "name": "If1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "segments",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{$items(\"Supabase - Get many rows\")[0].json.id}}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "start_time",
              "fieldValue": "={{$json.start_time}}"
            },
            {
              "fieldId": "end_time",
              "fieldValue": "={{$json.end_time}}"
            },
            {
              "fieldId": "provider",
              "fieldValue": "={{$json.provider}}"
            },
            {
              "fieldId": "start_location",
              "fieldValue": "={{$json.start_location}}"
            },
            {
              "fieldId": "end_time",
              "fieldValue": "={{$json.end_location}}"
            },
            {
              "fieldId": "confirmation",
              "fieldValue": "={{$json.confirmation}}"
            },
            {
              "fieldId": "website",
              "fieldValue": "={{$json.website}}"
            },
            {
              "fieldId": "phone",
              "fieldValue": "={{$json.phone}}"
            },
            {
              "fieldId": "description",
              "fieldValue": "={{$json.description}}"
            },
            {
              "fieldId": "notes",
              "fieldValue": "={{$json.notes}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        848,
        1088
      ],
      "id": "531701c8-3c3f-47a9-9855-a78efce9d37f",
      "name": "Update a row",
      "credentials": {
        "supabaseApi": {
          "id": "2iEo9hyw5QPufkeh",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "tableId": "segments",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "trip_id",
              "fieldValue": "={{$json.trip_id}}"
            },
            {
              "fieldId": "user_id",
              "fieldValue": "={{$json.user_id}}"
            },
            {
              "fieldId": "type",
              "fieldValue": "={{$json.type}}"
            },
            {
              "fieldId": "title",
              "fieldValue": "={{$json.title}}"
            },
            {
              "fieldId": "start_time",
              "fieldValue": "={{$json.start_time}}"
            },
            {
              "fieldId": "end_time",
              "fieldValue": "={{$json.end_time}}"
            },
            {
              "fieldId": "start_location",
              "fieldValue": "={{$json.start_location}}"
            },
            {
              "fieldId": "end_time",
              "fieldValue": "={{$json.end_location}}"
            },
            {
              "fieldId": "provider",
              "fieldValue": "={{$json.provider}}"
            },
            {
              "fieldId": "confirmation",
              "fieldValue": "={{$json.confirmation}}"
            },
            {
              "fieldId": "website",
              "fieldValue": "={{$json.website}}"
            },
            {
              "fieldId": "phone",
              "fieldValue": "={{$json.phone}}"
            },
            {
              "fieldId": "description",
              "fieldValue": "={{$json.description}}"
            },
            {
              "fieldId": "notes",
              "fieldValue": "={{$json.notes}}"
            },
            {
              "fieldId": "source_message_id",
              "fieldValue": "={{$json.source_message_id}}"
            },
            {
              "fieldId": "source_thread_id",
              "fieldValue": "={{$json.source_thread_id}}"
            },
            {
              "fieldId": "source_subject",
              "fieldValue": "={{$json.source_subject}}"
            },
            {
              "fieldId": "source_used_pdf",
              "fieldValue": "={{$json.source_used_pdf}}"
            },
            {
              "fieldId": "source_pdf_filenames",
              "fieldValue": "={{$json.source_pdf_filenames}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        848,
        1280
      ],
      "id": "9bf37e74-7596-48db-b811-7980a3eef642",
      "name": "Create a row",
      "credentials": {
        "supabaseApi": {
          "id": "2iEo9hyw5QPufkeh",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "content": "## 6. Webhook\n- Looking up user by email\n- Finding matching trips by date\n- Checking for duplicates\n- Creating or updating segments",
        "width": 256
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        480,
        464
      ],
      "typeVersion": 1,
      "id": "53e3c23c-8dd9-4882-82a8-50cbcebad503",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://wsnohpeewbmonnojzhyw.supabase.co/functions/v1/ingest-travel-email",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer ZqYkBfNXZ-Db6KH"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.user_email }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        640,
        672
      ],
      "id": "c52e9b26-4ee8-48de-b93a-59dc160244e4",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "content": "## 7. Error handling",
        "height": 144,
        "width": 150
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        768,
        464
      ],
      "id": "4778a509-3e83-4a2e-b405-2a41717fc7b0",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "7079296a-ac78-4f2b-8a0d-d71711f8e249",
              "leftValue": "",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        800,
        688
      ],
      "id": "ef677958-ce5a-4ad9-b282-93cc1ca2aae0",
      "name": "If2"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Get many messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many messages": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Code in JavaScript2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript2": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Supabase - Get many rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get many messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase - Get many rows": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript3": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Update a row",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "c0eb918c-015a-4f2f-8b05-2522ebb040e2",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "2bc4dcb75589d191630a945ddba8487aaa6ef5f962b3e299cbecf2e356f08788"
  },
  "id": "YpGFKCvn9EneFa5M",
  "tags": []
}
